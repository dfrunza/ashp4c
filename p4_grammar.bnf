<p4program> := <declaration> { <declaration> }* | ';'

<declaration> := <constantDeclaration> | <externDeclaration> | <actionDeclaration> | <parserDeclaration> | <typeDeclaration>
    | <controlDeclaration> | <instantiation> | <errorDeclaration> | <matchKindDeclaration> | <functionDeclaration>

<nonTypeName> := IDENTIFIER | APPLY | KEY | ACTIONS | STATE | ENTRIES | TYPE

<name> := <nonTypeName> | TYPE_IDENTIFIER

<nonTableKwName> := IDENTIFIER | TYPE_IDENTIFIER | APPLY | STATE | TYPE

/* DF: <optAnnotations> et al. have been ommited */

<parameterList> := { <parameter> { ',' <parameter> }* }

<parameter> := <direction> <typeRef> <name> { '=' <expression> }

<direction> := { IN | OUT | INOUT }

<packageTypeDeclaration> := PACKAGE <name> <optTypeParameters> '(' <parameterList> ')'

<instantiation> := <typeRef> '(' <argumentList> ')' <name> ';'

<optConstructorParameters> := { '(' <parameterList> ')' }


/*****  PARSER  *****/

<parserDeclaration> := <parserTypeDeclaration> <optConstructorParameters> '{' <parserLocalElements> <parserStates> '}'

<parserLocalElements> := { <parserLocalElement> { <parserLocalElement> }* }

<parserLocalElement> := <constantDeclaration> | <variableDeclaration> | <instantiation> /* | <valueSetDeclaration> */

<parserTypeDeclaration> := PARSER <name> <optTypeParameters> '(' <parameterList> ')'

<parserStates> := <parserState> { <parserState> }*

<parserState> := STATE name '{' <parserStatements> <transitionStatement> '}'

<parserStatements> := { <parserStatement> { <parserStatement }* }

<parserStatement> := <assignmentOrMethodCallStatement> | <directApplication> | <parserBlockStatement>
  | <constantDeclaration> | <variableDeclaration> | <emptyStatement>

<parserBlockStatement> := '{' <parserStatements> '}'

<transitionStatement> := { TRANSITION <stateExpression> }

<stateExpression> := <name> ';' | <selectExpression>

<selectExpression> := SELECT '(' <expressionList> ')' '{' <selectCaseList> '}'

<selectCaseList> := { <selectCase> { <selectCase> }* }

<selectCase> := <keysetExpression> ':' <name> ';'

<keysetExpression> := <tupleKeysetExpression> | <simpleKeysetExpression>

<tupleKeysetExpression> := '(' <simpleKeysetExpression> { ',' <simpleKeysetExpression }* ')'

<simpleKeysetExpression> := <expression> /* { ( MASK | RANGE ) <expression> } */ | DEFAULT | DONTCARE

<valueSetDeclaration> := VALUESET '<' ( <baseType> | <tupleType> | <typeName> ) '>' '(' <expression> ')' <name> ';'


/*****  CONTROL  *****/

<controlDeclaration> := <controlTypeDeclaration> <optConstructorParameters> '{' { <controlLocalDeclaration> }* APPLY <controlBody> '}'

<controlTypeDeclaration> := CONTROL <name> <optTypeParameters> '(' <parameterList> ')'

<controlLocalDeclaration> := <constantDeclaration> | <actionDeclaration> /* | <tableDeclaration> */ | <instantiation> | <variableDeclaration>

<controlBody> := <blockStatement>


/*****  EXTERN  *****/

<externDeclaration> := EXTERN (
    <nonTypeName> <optTypeParameters> '{' <methodPrototypes> '}'
  | <functionPrototype> ';' )

<methodPrototypes> := { <methodPrototype> }*

<functionPrototype> := <typeOrVoid> <name> <optTypeParameters> '(' <parameterList> ')'

<methodPrototype> := <functionPrototype> ';'
  | TYPE_IDENTIFIER '(' <parameterList> ')' ';' /* constructor */


/*****  TYPES  *****/

<typeRef> := <baseType> | <typeName> | <specializedType> | <headerStackType> | <tupleType>

<namedType> := <typeName> | <specializedType>

<prefixedType> := TYPE_IDENTIFIER { '.' TYPE_IDENTIFIER }

<typeName> := <prefixedType>

<tupleType> := TUPLE '<' <typeArgumentList> '>'

<headerStackType> := <typeName> '[' <expression> ']'

<specializedType> := <prefixedType> '<' <typeArgumentList> '>'

<baseType> := BOOL | ERROR
  | INT { '<' <integerTypeSize> '>' }
  | BIT { '<' <integerTypeSize> '>' }
  | VARBIT { '<' <integerTypeSize> '>' }

<integerTypeSize> := INTEGER | '(' <expression> ')'

<typeOrVoid> := <typeRef> | VOID | IDENTIFIER /* may be a type variable */

<optTypeParameters> := { '<' <typeParameterList> '>' }

<typeParameterList> := <name> { ',' <name> }*

<realTypeArg> := DONTCARE | <typeRef>

<typeArg> := DONTCARE | <typeRef> | <nonTypeName>

<realTypeArgumentList> := <realTypeArg> { ',' <realTypeArg> /* DF: the spec says it should be <typeArg> */ }*

<typeArgumentList> := { <typeArg> { ',' <typeArg> }* }

<typeDeclaration> := <derivedTypeDeclaration> | <typedefDeclaration> | <parserTypeDeclaration> ';'
  | <controlTypeDeclaration> ';' | <packageTypeDeclaration> ';'

<derivedTypeDeclaration> := <headerTypeDeclaration> | <headerUnionDeclaration> | <structTypeDeclaration> | <enumDeclaration>

<headerTypeDeclaration> := HEADER <name> '{' <structFieldList> '}'

<headerUnionDeclaration> := HEADER_UNION <name> '{' <structFieldList> '}'

<structTypeDeclaration> := STRUCT <name> '{' <structFieldList> '}'

<structFieldList> := { <structField> { ',' <structField> }* }

<structField> := <typeRef> <name> ';'

<enumDeclaration> := ENUM { BIT '<' INTEGER '>' } <name> '{' <specifiedIdentifierList> '}'

<errorDeclaration> := ERROR '{' <identifierList> '}'

<matchKindDeclaration> := MATCH_KIND '{' <identifierList> '}'

<identifierList> := <name> { ',' <name> }*

<specifiedIdentifierList> := <specifiedIdentifier> { ',' <specifiedIdentifier> }*

<specifiedIdentifier> := <name> '=' <initializer>

<typedefDeclaration> :=
    TYPEDEF ( <typeRef> | <derivedTypeDeclaration> ) <name> ';'
  | TYPE ( <typeRef> | <derivedTypeDeclaration> ) <name> ';'


/*****  STATEMENTS  *****/

<assignmentOrMethodCallStatement> := <lvalue> (
  | { '<' <typeArgumentList> '>' } '(' <argumentList> ')' ';'
  | '=' <expression> ';' )

<emptyStatement> := ';'

<returnStatement> := RETURN { expression } ';'

<exitStatement> := EXIT ';'

<conditionalStatement> := IF '(' <expression> ')' <statement> { ELSE <statement> }

/* To support direct invocation of a control or parser without instantiation */
<directApplication> := <typeName> '.' APPLY '(' <argumentList> ')' ';'

<statement> := <assignmentOrMethodCallStatement> | <directApplication> | <conditionalStatement>
  | <emptyStatement> | <blockStatement> | <exitStatement> | <returnStatement> /* | <switchStatement> */

<blockStatement> := '{' <statementOrDeclList> '}'

<statementOrDeclList> := { <statementOrDeclaration> }*

/* DF: <switchStatement> et al. have been ommited */

<statementOrDeclaration> := <variableDeclaration> | <constantDeclaration> | <statement> | <instantiation>


/*****  TABLES  *****/
/* DF: Tables have been ommited */


/*****  ACTION  *****/

<actionDeclaration> := ACTION <name> '(' <parameterList> ')' <blockStatement>


/*****  VARIABLES  *****/

<variableDeclaration> := VAR <typeRef> <name> <optInitializer> ';'

<constantDeclaration> := CONST <typeRef> <name> '=' <initializer> ';'

<optInitializer> := { '=' <initializer> }

<initializer> := <expression>


/*****  EXPRESSIONS  *****/

<functionDeclaration> := <functionPrototype> <blockStatement>

<argumentList> := { <argument> { ',' <argument> } }

<argument> := <expression> | <name> '=' <expression> | DONTCARE

<kvList> := <kvPair> { ',' <kvPair> }*

<kvPair> := <name> '=' <expression>

<expressionList> := { <expression> { ',' <expression> }* }

/* DF: <annotationBody> et al. have been ommited */

<member> := <name>

<prefixedNonTypeName> := { '.' } <nonTypeName>

<lvalue> := <prefixedNonTypeName> {
      '.' <member>
    | '[' <expression> { ':' <expression> } ']' }*

<expression> := <expressionPrimary> { <exprOperator> <expression> }*

<expressionPrimary> := INTEGER | TRUE | FALSE | STRING_LITERAL
  | { '.' /* TOK_UNARY_DOTPREFIX */ } <nonTypeName>
  | '{' <expressionList> /* | <kvList> */ '}'
  | '(' <expression> ')'
  | '!' <expression>
  | '-' /* TOK_UNARY_MINUS */ <expression>
  | ( <typeName> | ERROR ) '.' <member>
  | <namedType> '(' <argumentList> ')'
  | CAST '(' <typeRef> ')' <expression>

<exprOperator> :=
  | <binaryOperator>
  | '.' <member>
  | '[' <expression> { ':' <expression> } ']' /* array indexer */
  | '(' <argumentList> ')' /* function call */
  | '<' <realTypeArgumentList> '>'

<binaryOperator> := '*' | '/' | '+' | '-' | '<=' | '>=' | '<' | '>' | '!='
  | '==' | '||' | '&&' | '|' | '&'



/**************    OLD STUFF   *************/

<const_decl> := 'const' <typeref> <name> '=' <initializer> ';'

<package_prototype> := 'package' identifier { type_parameter_list } '(' <parameter_list> ')' ';'

<extern_decl> := 'extern' ( <extern_object> | <function_prototype> )

<extern_object> := identifier '{' { <function_prototype> }* '}'

<function_prototype> := type_identifier identifier { type_parameter_list } '(' <parameter_list> ')' ';'

<type_parameter_list> := '<' identifier { ',' <identifier> }* '>'

<instantiation> := <type_expression> '(' <argument_list> ')' identifier ';'

<control_decl> := <control_prototype> '{' { <control_local_decl> }* 'apply' <control_body> '}'

<control_prototype> := 'control' identifier '(' <parameter_list> ')'

<control_local_decl> := <action_decl> | <table_decl> | <var_decl>

<var_decl> := 'var' type_identifier identifier { '=' <expression> } ';'

<action_decl> := 'action' identifier '(' <parameter_list> ')' '{' <block_statement> '}'

<table_decl> := 'table' identifier '{' <table_prop> { <table_prop> }* '}'

<table_prop> := 'key' '=' '{' { <key_element> }* '}' |
  'actions' '=' '{' { <action> }* '}' |
  identifier '=' <expression>  ';'

<key_element> := <expression> ':' identifier ';'

<action> := identifier { '(' <argument_list> ')' } ';'

<control_body> := <block_statement>

<block_statement> := '{' { <stmt_or_decl> }* '}'

<stmt_or_decl> := <statement> | <var_decl>

<statement> := <expression> /* <if_statement> | ..? */

<parser_decl> := <parser_prototype> '{' { <parser_local_elements> } { <parser_state> }* '}'

<parser_local_elements> := { <block_statement> | <statement> }*

<parser_prototype> := 'parser' identifier { type_parameter_list } '(' { <parameter_list> } ')'

<parser_state> := 'state' identifier '{' { <parser_statement> }* <transition_statement> '}'

<parser_statement> := <expression> ';'

<transition_statement> := 'transition' <state_expression>

<state_expression> := ( identifier ';' ) | <select_expression>

<select_expression> := 'select' '(' { <expression> } ')' '{' { <select_case_list> } '}'

<select_case_list> := <select_case> { <select_case> }*

<select_case> := <simple_keyset_expression> ':' identifier ';'

<simple_keyset_expression> := <expression> | 'default'

<parameter_list> := <parameter> { ',' <parameter> }

<parameter> := { <direction> } <type_expression> identifier

<direction> := 'in' | 'out' | 'inout'

<expression> := <expression_primary> { <operator> <expression> }*

<expression_primary> := identifier | integer | 'true' | 'false' | 'string' |
    'error' | '(' <expression> ')'

<operator> := '.' | '==' | '(' { <argument_list> } ')'

<argument_list> := <argument> { ',' <argument> }*

<argument> := <expression>

<error_type_decl> := 'error' '{' <identifier_list> '}'

<identifier_list> := identifier { ',' identifier }*

<struct_field> := <type_expression> identifier ';'

<struct_decl> := 'struct' identifier '{' { <struct_field> }* '}'

<header_decl> := 'header' identifier '{' { <struct_field> }* '}'

<typedef_decl> := 'typedef' <type_expression> identifier ';'

<type_expression> := type_identifier | <typexpr_parameter_list> | <bit_typexpr> | <int_typexpr>

<typexpr_parameter_list> := '<' <type_identifier> { ',' <type_identifier> } '>'

<bit_type_expr> := 'bit' { '<' integer '>' }

<int_type_expr> := 'int' { '<' integer '>' }

--------------------------------------------------------------------------------

